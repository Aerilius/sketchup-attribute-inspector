=begin
Permission to use, copy, modify, and distribute this software for
any purpose and without fee is hereby granted, provided that the above
copyright notice appear in all copies.

THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

Name:         Dialog.rb
Author:       Andreas Eisenbarth
Description:  Subclass for UI::WebDialog.
              This subclass implements a communication system between Ruby.
Usage:

Create an instance (with the same arguments as UI::WebDialog):

    dialog = Dialog.new(*args)

Add an event handler when the dialog is shown: (show{} was unreliable in some SketchUp versions)

    dialog.on_show{ }

Add an event handler/callback, that receives any amount of arguments of any JSON type:

    dialog.on(String){ |dlg, *args| }

Remove an event handler/callback:

    dialog.off(String)

Call a JavaScript callback from a Ruby callback synchronously or asynchronously,
with any amount of arguments. You can pass this 'dlg' reference through any
methods or code blocks and call it later:

    dlg.return(*args)

Call a public JavaScript function with any amount of arguments of any JSON type:

    dialog.call_function(String, *args)

Requires:     JavaScript module AE.Bridge.
              Call AE.Bridge.initialize() at the end of your HTML document.
Version:      1.1.6
Date:         03.03.2015
=end


module AE


class AttributeInspector


# A subclass of UI::WebDialog.
class Dialog < UI::WebDialog


attr_accessor :bridge


def initialize
  super
  @bridge = Bridge.new(self)
end


def on(name, *arguments, &callback)
  @bridge.on(name, *arguments, &callback)
  return self
end


def off(name)
  @bridge.off(name)
  return self
end


def call(function, *arguments, &callback)
  @bridge.call(function, *arguments, &callback)
end


# Shows an "always on top" dialog, which is called not modal on Windows but modal on OSX.
# @param [Proc] block to execute when the dialog shows.
def show(&block)
  if ( Object::RUBY_PLATFORM =~ /darwin/i )
    show_modal(&block)
  else
    super
  end
end


class Bridge


def self.decorate(dialog)
  bridge = self.new(dialog)
  dialog.instance_variable_set(:@bridge, bridge)
  def dialog.bridge
    return @bridge
  end
  def dialog.on(name, *arguments, &callback)
    @bridge.on(name, *arguments, &callback)
    return self
  end
  def off(name)
    @bridge.off(name)
    return self
  end
  def call(function, *arguments, &callback)
    @bridge.call(function, *arguments, &callback)
  end
end


JAVASCRIPT_MODULE = "AE.Bridge"
HANDLER_RECEIVE   = "#{JAVASCRIPT_MODULE}.receive"
RESERVED_NAMES = [HANDLER_RECEIVE]
ACTION_CALLBACK_WRAPPER = Proc.new{ |dialog, *arguments| dialog.action_callback_wrapper(dialog, *arguments) }


attr_reader :dialog


# Add a callback handler.
# @param [String] name
# @param [Proc,UnboundMethod] callback
def on(name, *arguments, &callback)
  raise(ArgumentError, "Argument 'name' must be a String.") unless name.is_a?(String)
  raise(ArgumentError, "Argument 'name' can not be '#{name}'.") if RESERVED_NAMES.include?(name)
  raise(ArgumentError, "Must have a Proc.") unless block_given?
  @handlers[name] = callback
  return self
end


# Remove a callback handler.
# @param [String] name
def off(name)
  raise(ArgumentError, "Argument 'callback_name' must be a String.") unless name.is_a?(String)
  @handlers.delete(name)
  return self
end


# Call a JavaScript function with JSON arguments in the webdialog.
# @param [String] name of a public JavaScript function
# @params [Object] arguments array of JSON-compatible objects
def call(name, *arguments)
  arguments = JSON.stringify(arguments)[1...-1]
  arguments = "undefined" if arguments.nil? || arguments.empty?
  #@dialog.execute_script("#{name}(#{arguments})")
  # TODO: return value? #################################################################################
  @dialog.execute_script("#{JAVASCRIPT_MODULE}.call('JAVASCRIPT_MODULE.return', #{name}(#{arguments}) )")
  return @result
  # Get the return value from the hidden input element.
  #value = dialog.get_element_value("#{JAVASCRIPT_MODULE}.messageField")
  #data = JSON.parse(value)
end


# Call a JavaScript function with JSON arguments in the webdialog and get the return value.
# @param [String] name of a public JavaScript function
# @params [Object] arguments array of JSON-compatible objects
# @returns [Promise]
def get(name, *arguments)
  arguments = JSON.stringify(arguments)[1...-1]
  arguments = "undefined" if arguments.nil? || arguments.empty?
  #@dialog.execute_script("#{name}(#{arguments})")
  # TODO: return value? #################################################################################
  @dialog.execute_script("#{JAVASCRIPT_MODULE}.call('JAVASCRIPT_MODULE.return', #{name}(#{arguments}) )")
  return @result
  # Get the return value from the hidden input element.
  #value = dialog.get_element_value("#{JAVASCRIPT_MODULE}.messageField")
  #data = JSON.parse(value)
end


private


def initialize(dialog)
  @dialog = dialog
  @handlers = {}
  @handlers_show = []
  @handlers_close = []

  # SketchUp does not release procs of WebDialogs. Because of that, we need to
  # make sure that the proc contains no reference to this instance. The proc
  # receives a reference to this dialog, so it can call the follow-up method #action_callback.
  @dialog.add_action_callback(HANDLER_RECEIVE, &ACTION_CALLBACK_WRAPPER)

  add_default_handlers()
end


# Receives the raw messages from the WebDialog (AE.Bridge.call) and calls the individual callbacks.
# @private - Not for public use.
# @param [UI::WebDialog] dialog
# @param [String] param
def action_callback_wrapper(dialog, param)
  # Get message data from the hidden input element.
  value = dialog.get_element_value("#{JAVASCRIPT_MODULE}.messageField")
  data = JSON.parse(value)
  
  unless data.is_a?(Hash) &&
         data["id"].is_a?(Fixnum) &&
         data["name"].is_a?(String) &&
         data["arguments"].is_a?(Array)
    raise(ArgumentError, "Dialog received invalid data: \n#{value}")
  end
  id = data["id"]
  name = data["name"]
  arguments = data["arguments"] || []

  # Here we pass a wrapper around the dialog which preserves the message id to
  # identify the corresponding JavaScript callback.
  # This allows to run asynchronous code (external application etc.) and return
  # later the result to the JavaScript callback even if the dialog has continued
  # sending/receiving messages.
  message = Message.new(dialog, id)
  # Get the callback.
  unless @handlers.include?(name)
    error = ArgumentError.new("No registered callback '#{name}' for #{dialog} found.")
    message.reject(error)
    raise(error)
  end
  handler = @handlers[name]
  begin
    handler.call(message, *arguments)
  rescue Exception => error
    message.reject(error)
    raise(error)
  end

rescue Exception => e
  if defined?(AE::Console)
    AE::Console.error(e)
  else
    $stderr.write(e.message + $/)
    $stderr.write(e.backtrace.join($/) + $/)
  end
ensure
  # Acknowledge that the message has been received and enable the bridge to send 
  # the next message if available.
  dialog.execute_script("#{JAVASCRIPT_MODULE}.ack()")
end


def add_default_handlers
  # Return (for return values of function calls)
  @handlers["#{JAVASCRIPT_MODULE}.return"] = Proc.new{ |dialog, result|
    @result = result
  }

  # Puts (for debugging)
  @handlers["#{JAVASCRIPT_MODULE}.puts"] = Proc.new{ |dialog, *arguments|
    puts(*arguments.map{ |argument| argument.inspect })
  }

  # Error channel (for debugging)
  @handlers["#{JAVASCRIPT_MODULE}.error"] = Proc.new{ |dialog, type, message, backtrace|
    if defined?(AE::Console)
      AE::Console.error("#{type}: #{message}", {:language => "javascript", :backtrace => backtrace})
    else
      $stderr.write("#{type}: #{message}" << $/)
      $stderr.write(backtrace.join($/) << $/)
    end
  }

=begin
  # Try to set the default dialog color as background. # TODO Test on Windows 7 and OS X if this is still necessary.
  # This is a workaround because on some systems/browsers the CSS system color is
  # wrong (white), and on some systems SketchUp returns white (also mostly wrong).
  @handlers_show << Proc.new{ |dialog|
    color = dialog.get_default_dialog_color
    # If it's white, then it is likely not correct and we try the CSS system color instead.
    color = "Window" if color == "#ffffff"
    script = "if (!document.body.style.background && " <<
      "!document.body.style.backgroundColor) { " <<
      "document.body.style.backgroundColor = '#{color}'; }"
    dialog.execute_script(script)
  }
=end
end


# Give a short string for inspection. This does not output instance variables
# since these contain a lot of data, references to other objects and self-references.
#
# @return [String] the instance's class and object id
def inspect
  return "#<#{self.class}:0x#{(self.object_id << 1).to_s(16)}>"
end


# Wrapper class around the dialog so that Ruby callbacks can remember the
# corresponding JavaScript callback id.
class Message


  def initialize(bridge, id)
    @bridge = bridge
    @id = id
  end


  def resolve(*results)
    arguments = JSON.stringify(results)[1...-1]
    arguments = "undefined" if arguments.nil? || arguments.empty?
    @bridge.dialog.execute_script("#{JAVASCRIPT_MODULE}.resolve(#{@id}, #{arguments})")
  end
  alias_method :return, :resolve


  def reject(reason)
    raise ArgumentsError unless reason.is_a?(Exception) || reason.is_a?(String)
    if reason.is_a?(Exception)
      error_class = case Exception
      when NameError     then "ReferenceError"
      when SyntaxError   then "SyntaxError"
      when TypeError     then "TypeError"
      when ArgumentError then "TypeError"
      else # any Exception
        "Error"
      end
      reason = "new #{error_class}(#{reason.message.inspect})"
    end
    @bridge.dialog.execute_script("#{JAVASCRIPT_MODULE}.reject(#{@id}, #{reason})")
  end


  def method_missing(method_name, *arguments)
    return @dialog.__send__(method_name, *arguments)
  end


end # class Message



module JSON


# Prefer to use json lib if available (optional).
# Sketchup::require "json" # Raises no error, but displays in load errors popup.
if Sketchup.version.to_i >= 14
  begin; load "json.rb" unless defined?(JSON); rescue LoadError; end
end


# Read a JSON string and return a hash.
# @param [String] json_string
# @return [Hash,Array,String,Numeric,Boolean,NilClass]
def parse(json_string)
  raise(ArgumentError, "Argument 'json_string' must be a String.") unless json_string.is_a?(String)
  
  # Use JSON library if available.
  # Only generation of JSON objects or arrays allowed, so we wrap it into an array (it could be a String etc.).
  if defined?(JSON)
    return JSON.parse("["+json_string+"]").first
  
  # Otherwise we use an alternative json implementation.
  else
    return parse_implementation(json_string)
  end
end


# This converts Ruby objects into JSON.
# @params [Hash,Array,String,Numeric,Boolean,NilClass] object
# @return [String] JSON string
def stringify(object)
  raise(ArgumentError, "Argument 'object' must be one of #{JSON_CLASSES.join(', ')}") 
    unless json_classes.include?(object.class)

  # Remove non-JSON objects because they would end up as inspected strings like #<Object>.
  o = sanitize_object(object)

  # Use JSON lib if available.
  # Only generation of JSON objects or arrays allowed, so we wrap it into an array (it could be a String etc.).
  return JSON.generate([o])[1...-1] if defined?(JSON)

  # Otherwise we use an alternative json implementation.
  else
    return parse_implementation(json_string)
  end
end


class << self


private


JSON_CLASSES = [String, Symbol, Fixnum, Float, Array, Hash, TrueClass, FalseClass, NilClass]


def parse_implementation(json_string)
  # Split at every even number of unescaped quotes. This gives either strings
  # or what is between strings.
  # ruby_string = json_string.split(/(\"(?:.*?[^\\])*?\")/).
  ruby_string = json_string.split(/\"(?:\\\"|[^\"])*\"/).
    map{ |string|
      next string if string[0..0] == '"' # is a string in quotes
      # Don't allow arbitrary textual expressions outside of strings.
      raise if string[/(?!(null|undefined))/] && string[/\w/]
      # If it's not a string then replace : and null
      string.gsub(/\:/, "=>").
             gsub(/\bnull\b/, "nil").
             gsub(/\bundefined\b/, "nil")
    }.
    join("")
  result = eval(ruby_string)
  return result
end


def stringify_implementation(object)
  # Split at every even number of unescaped quotes. This gives either strings
  # or what is between strings.
  #json_string = object.inspect.split(/(\"(?:.*?(?:[\\][\\]+?|[^\\]))*?\")/).
  json_string = object.inspect.split(/\"(?:\\\"|[^\"])*\"/).
    map{ |string|
      next string if string[0..0] == '"' # is a string in quotes
      # If it's not a string then replace : and null
      string.gsub(/\=\>/, ":").
             gsub(/\bnil\b/, "null")
    }.
    join("")
  return json_string
end


def sanitize_object(object)
  case object
  when Array
    sanitized = []
    object.each{ |a|
      sanitized << sanitize_object(a) if JSON_CLASSES.include?(a.class)
    }
    return sanitized
  when Hash
    sanitized = {}
    object.each{ |k, v|
      if (k.is_a?(String) || k.is_a?(Symbol)) && JSON_CLASSES.include?(v.class)
        sanitized[k.to_s] = sanitize_object(v)
      end
    }
    return sanitized
  when Symbol
    return object.to_s
  else
    return object
  end
end


end # class << self


end # module JSON


end # class Bridge


end # class Dialog


end


end # module AE
